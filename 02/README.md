# 第2章 序列构成的数组

**2.2.2 列表推导同filter和map的比较**

```python
list(filter(lambda c: c > 127, map(ord, symbols)))
```

**2.2.3 笛卡尔积**

```python
[(color, size) for color in colors
               for size in sizes]
```

* 列表推导的作用只有一个：生成列表

**2.2.4 生成器表达式**

* 生成器表达式背后遵守了迭代器协议，可以逐个地产出元素
* 生成器表达式的语法跟列表推导差不多，只不过把方括号换成圆括号而已
* 如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要额外再用括号把它围 起来

```python
(ord(symbol) for symbol in symbols)

('%s %s' % (c, s) for c in colors for s in sizes)
```

## 2.3 元组不仅仅是不可变的列表

**2.3.1 元组和记录**

* 元组中的每个元素都存放了记录中一个字段的数据，外加这个 字段的位置。正是这个位置信息给数据赋予了意义
* 但是如果把元组当作一些字段的集合，那么数量和位置信息 就变得非常重要了

```python
# % 格式运算符能被匹配到对应的元组元素上
'%s/%s' % passport
```

```python
# for 循环可以分别提取元组里的元素，也叫作拆包（unpacking）
# 因为元组中第二个元素对我们没有什么用，所以它赋值给“ _ ”占位符。

for country, _ in traveler_ids:
```

**2.3.2 元组拆包**

* 可以用 * 运算符把一个可迭代对象拆开作为函数的参数
* 在平行赋值中， * 前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的 任意位置

**2.3.4 具名元组**

* `_fields` 类属性
* `_make(iterable)` 类方法
* `_asdirct()`


## 2.4 切片


* 在切片和区间操作里不包含区间范围的最后一个元素是 python 的风格

**2.4.2 对对象进行切片**

```python
seq[start:stop:step]
seq.__get_item__(slick(start, stop, step))
```

有名字的切片比用硬片吗的数字区间

```
SKU = slice(0, 6)
```

**2.4.3 多维切片和省略**

**建立由列表组成的列表**

```python
# 把一个序列复制几份然后在拼接起来，更快捷的做法是把这个序列乘以一个证书
# 不修改原有对象，而是构建一个全新的序列
[['_']*3 for i in range(3)]

# 错误案例
[['_']*3] * 3
```

## 2.6 序列的增量赋值

增量赋值运算符 += 和 *= 的表现取决于他们的第一个操作对象

```
+=、__iadd__、__add__
```
* id()

## Ref

* <https://pythontutor.com/>